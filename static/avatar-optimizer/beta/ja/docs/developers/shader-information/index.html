<!doctype html><html lang=ja dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Shader Information API
  #

Avatar Optimizer v1.8.0以降では、カスタムシェーダーが使用されているマテリアルの最適化を支援するためのShader Information APIを提供しています。
APIを通じてシェーダーの情報を登録することで、Avatar Optimizerはテクスチャのアトラス化やUVパッキングなどの高度な最適化を実行できるようになります。

  Shader Informationとは？
  #

Shader Informationは、テクスチャ、UVチャンネル、その他のマテリアルプロパティをシェーダーがどのように使用しているかをAvatar Optimizerに伝えるための方法です。
現在のAvatar Optimizerはこの情報を用いて、アバターに以下のような最適化を行います。
(将来的に、さらに多くの最適化が追加される可能性があります。1)
なお、すべての最適化がTrace and Optimizeで自動的に実行されるとは限りません。

複数のテクスチャをアトラス化し、パッキングする (AAO Merge Materialなどのコンポーネントを使用)
シェーダーの機能としては存在するが、マテリアル設定で無効化されていて使用されていないテクスチャの削除

Shaderの情報がない場合、Avatar Optimizerはシェーダーを慎重に取り扱うため、これらの最適化の一部を実行することができません。

  コンセプト
  #


  主要なクラス
  #

Shader Information APIは3つの主要なクラスで構成されています。

ShaderInformation: シェーダーに関する情報を提供するために継承する基底クラス。
GetMaterialInformationメソッドをオーバーライドして、そのシェーダーを使用するマテリアルがテクスチャとUVをどのように使用するかを登録します。
ShaderInformationRegistry: エディターの初期化処理中にShaderInformationの実装をAvatar Optimizerに登録するために使用する静的クラス。
MaterialInformationCallback: マテリアルプロパティを読み取ってテクスチャとUVの使用方法を伝えるためのメソッドを提供します。これはGetMaterialInformationに渡されます。


  Null値
  #

Shader Information API全体を通して、null値は不明な値またはアニメーションで操作される(静的に決定することのできない)値を表します。
マテリアルプロパティがアニメーションで操作されているなど、ビルド時にその値を決定できない場合、APIはその不確実性を示すためにnullを返します。
値を静的に決定できない場合は、パラメータにnullを渡す必要があります。

  使い方
  #

Shader Informationを提供するには、以下の手順に従ってください。

  1. Assembly Definitionを作成する
  #

シェーダーのパッケージにエディター向けのAssembly Definition2がない場合は、作成してください。
Shader Informationはビルド時にのみ使用され、Shader Information APIもエディター上でのみ利用可能であるため、エディター向けのアセンブリが必要です。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://vpm.anatawa12.com/avatar-optimizer/beta/ja/docs/developers/shader-information/"><meta property="og:site_name" content="Avatar Optimizer (1.9.6-beta.1)"><meta property="og:title" content="Shader Information API"><meta property="og:description" content="Shader Information API # Avatar Optimizer v1.8.0以降では、カスタムシェーダーが使用されているマテリアルの最適化を支援するためのShader Information APIを提供しています。
APIを通じてシェーダーの情報を登録することで、Avatar Optimizerはテクスチャのアトラス化やUVパッキングなどの高度な最適化を実行できるようになります。
Shader Informationとは？ # Shader Informationは、テクスチャ、UVチャンネル、その他のマテリアルプロパティをシェーダーがどのように使用しているかをAvatar Optimizerに伝えるための方法です。
現在のAvatar Optimizerはこの情報を用いて、アバターに以下のような最適化を行います。 (将来的に、さらに多くの最適化が追加される可能性があります。1)
なお、すべての最適化がTrace and Optimizeで自動的に実行されるとは限りません。
複数のテクスチャをアトラス化し、パッキングする (AAO Merge Materialなどのコンポーネントを使用) シェーダーの機能としては存在するが、マテリアル設定で無効化されていて使用されていないテクスチャの削除 Shaderの情報がない場合、Avatar Optimizerはシェーダーを慎重に取り扱うため、これらの最適化の一部を実行することができません。
コンセプト # 主要なクラス # Shader Information APIは3つの主要なクラスで構成されています。
ShaderInformation: シェーダーに関する情報を提供するために継承する基底クラス。
GetMaterialInformationメソッドをオーバーライドして、そのシェーダーを使用するマテリアルがテクスチャとUVをどのように使用するかを登録します。 ShaderInformationRegistry: エディターの初期化処理中にShaderInformationの実装をAvatar Optimizerに登録するために使用する静的クラス。 MaterialInformationCallback: マテリアルプロパティを読み取ってテクスチャとUVの使用方法を伝えるためのメソッドを提供します。これはGetMaterialInformationに渡されます。 Null値 # Shader Information API全体を通して、null値は不明な値またはアニメーションで操作される(静的に決定することのできない)値を表します。
マテリアルプロパティがアニメーションで操作されているなど、ビルド時にその値を決定できない場合、APIはその不確実性を示すためにnullを返します。
値を静的に決定できない場合は、パラメータにnullを渡す必要があります。
使い方 # Shader Informationを提供するには、以下の手順に従ってください。
1. Assembly Definitionを作成する # シェーダーのパッケージにエディター向けのAssembly Definition2がない場合は、作成してください。
Shader Informationはビルド時にのみ使用され、Shader Information APIもエディター上でのみ利用可能であるため、エディター向けのアセンブリが必要です。"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Shader Information API | Avatar Optimizer (1.9.6-beta.1)</title><link rel=icon href=/avatar-optimizer/beta/favicon.png><link rel=manifest href=/avatar-optimizer/beta/manifest.json><link rel=canonical href=https://vpm.anatawa12.com/avatar-optimizer/beta/ja/docs/developers/shader-information/><link rel=alternate hreflang=en href=https://vpm.anatawa12.com/avatar-optimizer/beta/en/docs/developers/shader-information/ title="Shader Information API"><link rel=stylesheet href=/avatar-optimizer/beta/book.min.e0a9d206623624a99ee922419f11e1110a88e06770d97913b11d9ecadaa614a9.css integrity="sha256-4KnSBmI2JKme6SJBnxHhEQqI4Gdw2XkTsR2eytqmFKk=" crossorigin=anonymous><script defer src=/avatar-optimizer/beta/fuse.min.js></script><script defer src=/avatar-optimizer/beta/ja.search.min.7e2a9d5f9c8dbfc33816b9a355edcefc6df3e0d02ddce1e544cd9720887ea7f5.js integrity="sha256-fiqdX5yNv8M4FrmjVe3O/G3z4NAt3OHlRM2XIIh+p/U=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/avatar-optimizer/beta/ja/><span>Avatar Optimizer (1.9.6-beta.1)</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/avatar-optimizer/beta/svg/translate.svg class=book-icon alt=Languages>
日本語</a></label><ul><li><a href=/avatar-optimizer/beta/en/docs/developers/shader-information/>English</a></li></ul></li></ul><ul><li><a class=ao-stable-beta href=https://vpm.anatawa12.com/avatar-optimizer/ja/docs/developers/shader-information/>Goto Stable Docs</a></li><li><a class=ao-stable-beta href=https://vpm.anatawa12.com/avatar-optimizer/beta/ja/#installation>インストール方法</a></li></ul><ul><li class=book-section-flat><span>チュートリアル</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/tutorial/basic-usage/>基本的な使い方</a></li></ul></li><li><a href=/avatar-optimizer/beta/ja/docs/basic-concept/>基本コンセプト</a></li><li><a href=/avatar-optimizer/beta/ja/docs/faq/>よくある質問</a></li><li><a href=/avatar-optimizer/beta/ja/docs/bug-report-helper/>Bug Report Helper</a></li><li><a href=/avatar-optimizer/beta/ja/docs/changelog/>Changelog</a></li><li class=book-section-flat><span>コンポーネントの種類</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/component-kind/avatar-global-components/>Avatar Global Components</a></li><li><a href=/avatar-optimizer/beta/ja/docs/component-kind/edit-skinned-mesh-components/>Edit Skinned Mesh Components</a></li></ul></li><li class=book-section-flat><span>コンポーネントの詳細説明</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/reference/trace-and-optimize/>Trace And Optimize</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-skinned-mesh/>Merge Skinned Mesh</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/freeze-blendshape/>Freeze BlendShape</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/max-texture-size/>Max Texture Size</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-material/>Merge Material</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-blendshape/>Remove Mesh By BlendShape</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-box/>Remove Mesh By Box</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-mask/>Remove Mesh By Mask</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-uv-tile/>Remove Mesh By UV Tile</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/rename-blendshape/>Rename BlendShape</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/clear-endpoint-position/>Clear Endpoint Position</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-bone/>Merge Bone</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-physbone/>Merge PhysBone</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-zero-sized-polygon/>Remove Zero Sized Polygon</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/replace-end-bone-with-endpoint-position/>Replace End Bone With Endpoint Position</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/make-children/>Make Children</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-toonlit-material/>Merge ToonLit Material</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/unused-bones-by-references-tool/>UnusedBonesByReferencesTool</a></li></ul></li><li class=book-section-flat><span>開発者向け</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/developers/system-assumptions/>システムの前提条件</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/asset-description/>Asset Description</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/component-api/>Component Scripting API</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/shader-information/ class=active>Shader Information API</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/distributing-prefabs/>アセットの配布について</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/make-your-components-compatible-with-aao/>コンポーネントにAvatar Optimizerとの互換性をもたせる</a></li></ul></li></ul><ul><li class=book-section-flat><span>Blog Posts</span><ul><li><a href=/avatar-optimizer/beta/ja/posts/2024-06-27-one-year-since-stable-release/>v1.0.0一周年を記念してちょっと歴史を振り返る</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/avatar-optimizer/beta/svg/menu.svg class=book-icon alt=Menu></label><h3>Shader Information API</h3><label for=toc-control><img src=/avatar-optimizer/beta/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-is-shader-information>Shader Informationとは？</a></li><li><a href=#core-concepts>コンセプト</a><ul><li><a href=#main-classes>主要なクラス</a></li><li><a href=#null-values>Null値</a></li></ul></li><li><a href=#getting-started>使い方</a><ul><li><a href=#create-asmdef>1. Assembly Definitionを作成する</a></li><li><a href=#add-reference>2. Assembly Referenceを追加する</a></li><li><a href=#create-class>3. Shader Informationクラスを作成</a></li></ul></li><li><a href=#information-kinds>ShaderInformationKindフラグ</a></li><li><a href=#registering-information>マテリアル情報の登録</a><ul><li><a href=#reading-properties>マテリアルプロパティの読み取り</a></li><li><a href=#registering-textures>テクスチャ使用状況の登録</a></li><li><a href=#register-vertex-index>頂点インデックス使用状況の登録</a></li></ul></li><li><a href=#registration-methods>Shader Informationの登録</a><ul><li><a href=#register-by-guid>GUIDで登録する (推奨)</a></li><li><a href=#register-by-instance>シェーダーインスタンスで登録する</a></li></ul></li><li><a href=#best-practices>ベストプラクティス</a><ul><li><a href=#use-initializeonload>InitializeOnLoadを使用する</a></li><li><a href=#handle-unknown-values>nullの取り扱い</a></li><li><a href=#check-keywords-properties>キーワードとプロパティを確認する</a></li><li><a href=#provide-accurate-information>正確な情報を提供する</a></li><li><a href=#use-internal-class>Shader Informationクラスに<code>internal class</code>を使用する</a></li></ul></li><li><a href=#examples>記述例</a><ul><li><a href=#example-simple>メインテクスチャを持つシンプルなシェーダー</a></li><li><a href=#example-conditional>条件付きで機能が有効になるシェーダー</a></li><li><a href=#example-vertex-indices>頂点インデックスを使用するシェーダー</a></li></ul></li><li><a href=#support>サポート</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=shader-information-api>Shader Information API
<a class=anchor href=#shader-information-api>#</a></h1><p>Avatar Optimizer v1.8.0以降では、カスタムシェーダーが使用されているマテリアルの最適化を支援するためのShader Information APIを提供しています。<br>APIを通じてシェーダーの情報を登録することで、Avatar Optimizerはテクスチャのアトラス化やUVパッキングなどの高度な最適化を実行できるようになります。</p><h2 id=what-is-shader-information>Shader Informationとは？
<a class=anchor href=#what-is-shader-information>#</a></h2><p>Shader Informationは、テクスチャ、UVチャンネル、その他のマテリアルプロパティをシェーダーがどのように使用しているかをAvatar Optimizerに伝えるための方法です。</p><p>現在のAvatar Optimizerはこの情報を用いて、アバターに以下のような最適化を行います。
(将来的に、さらに多くの最適化が追加される可能性があります。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>)<br>なお、すべての最適化がTrace and Optimizeで自動的に実行されるとは限りません。</p><ul><li>複数のテクスチャをアトラス化し、パッキングする (<code>AAO Merge Material</code>などのコンポーネントを使用)</li><li>シェーダーの機能としては存在するが、マテリアル設定で無効化されていて使用されていないテクスチャの削除</li></ul><p>Shaderの情報がない場合、Avatar Optimizerはシェーダーを慎重に取り扱うため、これらの最適化の一部を実行することができません。</p><h2 id=core-concepts>コンセプト
<a class=anchor href=#core-concepts>#</a></h2><h3 id=main-classes>主要なクラス
<a class=anchor href=#main-classes>#</a></h3><p>Shader Information APIは3つの主要なクラスで構成されています。</p><ul><li><code>ShaderInformation</code>: シェーダーに関する情報を提供するために継承する基底クラス。<br><code>GetMaterialInformation</code>メソッドをオーバーライドして、そのシェーダーを使用するマテリアルがテクスチャとUVをどのように使用するかを登録します。</li><li><code>ShaderInformationRegistry</code>: エディターの初期化処理中に<code>ShaderInformation</code>の実装をAvatar Optimizerに<a href=#registration-methods>登録</a>するために使用する静的クラス。</li><li><code>MaterialInformationCallback</code>: マテリアルプロパティを読み取ってテクスチャとUVの使用方法を伝えるためのメソッドを提供します。これは<code>GetMaterialInformation</code>に渡されます。</li></ul><h3 id=null-values>Null値
<a class=anchor href=#null-values>#</a></h3><p>Shader Information API全体を通して、<code>null</code>値は<strong>不明な値</strong>または<strong>アニメーションで操作される(静的に決定することのできない)値</strong>を表します。<br>マテリアルプロパティがアニメーションで操作されているなど、ビルド時にその値を決定できない場合、APIはその不確実性を示すために<code>null</code>を返します。<br>値を静的に決定できない場合は、パラメータに<code>null</code>を渡す必要があります。</p><h2 id=getting-started>使い方
<a class=anchor href=#getting-started>#</a></h2><p>Shader Informationを提供するには、以下の手順に従ってください。</p><h3 id=create-asmdef>1. Assembly Definitionを作成する
<a class=anchor href=#create-asmdef>#</a></h3><p>シェーダーのパッケージにエディター向けのAssembly Definition<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>がない場合は、作成してください。<br>Shader Informationはビルド時にのみ使用され、Shader Information APIもエディター上でのみ利用可能であるため、エディター向けのアセンブリが必要です。</p><h3 id=add-reference>2. Assembly Referenceを追加する
<a class=anchor href=#add-reference>#</a></h3><p>asmdefファイルのアセンブリ参照に<code>com.anatawa12.avatar-optimizer.api.editor</code>を追加してください。</p><p>Avatar Optimizerを必須の依存関係にしたくない場合は、<code>AVATAR_OPTIMIZER</code>のようなシンボルで<a href=https://docs.unity3d.com/2019.4/Documentation/Manual/ScriptCompilationAssemblyDefinitionFiles.html#define-symbols>Version Defines</a>を使用して、Avatar Optimizerがインストールされているか、および、AAOのバージョンが特定のバージョンより新しいかを検出することができます。</p><p><img src=../version-defines.png alt=version-defines.png></p><p>ここでは、<code>[1.8,2.0)</code>のようなバージョン範囲を指定することを推奨します。(v1.8.0以降をサポートしますが、v2.0.0以降には更新が必要になることを意味します)<br>一部のAPIは後のバージョンから追加される可能性があるため、使用するAPIに基づいてバージョン範囲を調整しなければならない可能性があることにご注意ください。</p><h3 id=create-class>3. Shader Informationクラスを作成
<a class=anchor href=#create-class>#</a></h3><p><code>ShaderInformation</code>を継承するクラスを作成し、<code>ShaderInformationRegistry</code>に登録してください。<br>Avatar Optimizerがマテリアルを処理する前に登録されることを保証するため、登録には<code>[InitializeOnLoad]</code>属性とstaticコンストラクタを使用してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>#if</span> AVATAR_OPTIMIZER &amp;&amp; UNITY_EDITOR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Anatawa12.AvatarOptimizer.API;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> YourNamespace
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [InitializeOnLoad]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>YourShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> YourShaderInformation()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// シェーダーのGUIDで登録 (シェーダーアセットに推奨)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> shaderGuid = <span style=color:#e6db74>&#34;your-shader-guid-here&#34;</span>;
</span></span><span style=display:flex><span>            ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>                shaderGuid, 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>            ShaderInformationKind.TextureAndUVUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ここでテクスチャとUVの使用状況を登録 (次に示す例を参照)</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><h2 id=information-kinds>ShaderInformationKindフラグ
<a class=anchor href=#information-kinds>#</a></h2><p><code>SupportedInformationKind</code>プロパティは、Shader Informationから提供する情報の種類をAvatar Optimizerに伝えます。</p><p>現在は以下の2種類があります。</p><ul><li><code>TextureAndUVUsage</code>: シェーダーが使用するテクスチャや、各テクスチャがサンプリングを行うUVチャンネル、UVの変換行列、サンプラー状態に関する情報を提供していることを示します。<br>詳細は<a href=#registering-textures>テクスチャ使用状況の登録</a>を参照してください。</li><li><code>VertexIndexUsage</code>: シェーダーが頂点インデックス(例: <code>SV_VertexID</code>)を使用するという情報を提供していることを示します。<br>このフラグを提供しない場合、Avatar Optimizerは頂点インデックスは使用されていないものと仮定し、最適化中に頂点を入れ替える可能性があります。<br>詳細は<a href=#register-vertex-index>頂点インデックス使用状況の登録</a>を参照してください。</li></ul><p>これはフラグ用Enum型であるため、<code>|</code>演算子で複数の値を組み合わせることができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>    ShaderInformationKind.TextureAndUVUsage | ShaderInformationKind.VertexIndexUsage;
</span></span></code></pre></div><h2 id=registering-information>マテリアル情報の登録
<a class=anchor href=#registering-information>#</a></h2><p><code>GetMaterialInformation</code>メソッドは、シェーダーを使用する各マテリアルに対して呼び出されます。<br><code>MaterialInformationCallback</code>を使用して、テクスチャとUVの使用状況を登録してください。</p><p>各メソッドの詳細については、APIドキュメントのコメントを参照してください。</p><h3 id=reading-properties>マテリアルプロパティの読み取り
<a class=anchor href=#reading-properties>#</a></h3><p><code>MaterialInformationCallback</code>は、シェーダー上のマテリアルプロパティを読み取るメソッドを提供します。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// floatプロパティの読み取り</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float?</span> <span style=color:#66d9ef>value</span> = matInfo.GetFloat(<span style=color:#e6db74>&#34;_PropertyName&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// intプロパティの読み取り</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int?</span> <span style=color:#66d9ef>value</span> = matInfo.GetInt(<span style=color:#e6db74>&#34;_PropertyName&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Vector4プロパティの読み取り (_MainTex_STなど)</span>
</span></span><span style=display:flex><span>Vector4? <span style=color:#66d9ef>value</span> = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// シェーダーキーワードが有効かどうかの確認</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool?</span> enabled = matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;KEYWORD_NAME&#34;</span>);
</span></span></code></pre></div><p>これらのメソッドは、プロパティが存在しないか値が不明な場合に<code>null</code>を返します。</p><h3 id=registering-textures>テクスチャ使用状況の登録
<a class=anchor href=#registering-textures>#</a></h3><p><code>RegisterTextureUVUsage</code>メソッドを使用して、各2Dテクスチャに関する情報をAvatar Optimizerに伝えます。<br>パラメータの詳細については、APIドキュメントのコメントを参照してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// UV変換(スケールやオフセット)を取得</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>    Matrix2x3? uvMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st
</span></span><span style=display:flex><span>        ? Matrix2x3.NewScaleOffset(st)
</span></span><span style=display:flex><span>        : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// テクスチャを登録</span>
</span></span><span style=display:flex><span>    matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>        textureMaterialPropertyName: <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>        samplerState: <span style=color:#e6db74>&#34;_MainTex&#34;</span>,  <span style=color:#75715e>// _MainTexプロパティのサンプラーを使用</span>
</span></span><span style=display:flex><span>        uvChannels: UsingUVChannels.UV0,
</span></span><span style=display:flex><span>        uvMatrix: uvMatrix
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=sampler-states>サンプラー状態
<a class=anchor href=#sampler-states>#</a></h4><p>サンプラー状態はテクスチャのラッピングとフィルタリングを定義します。<br>ほとんどのシェーダーはマテリアルプロパティにあるサンプラーを使用するため、その場合はプロパティ名を使用してください。
(文字列は暗黙的に<code>SamplerStateInformation</code>に変換されます)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>    samplerState: <span style=color:#e6db74>&#34;_MainTex&#34;</span>,  <span style=color:#75715e>// 文字列は暗黙的に変換されます</span>
</span></span><span style=display:flex><span>    UsingUVChannels.UV0,
</span></span><span style=display:flex><span>    uvMatrix
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>シェーダーがインラインサンプラー(例: <code>SamplerState linearClampSampler</code>)を使用している場合は、<code>SamplerStateInformation.LinearRepeatSampler</code>のような定義済みの定数を使用してください。</p><p>サンプラーを決定できない場合は、<code>SamplerStateInformation.Unknown</code>を使用してください。</p><h4 id=uv-channels>UVチャンネル
<a class=anchor href=#uv-channels>#</a></h4><p><code>UsingUVChannels</code>メソッドを使用して、テクスチャがサンプリングを行うUVチャンネルを指定します。<br>メッシュUVを使用しないテクスチャ(スクリーンスペース、MatCap、ビュー方向が基準など)の場合は、<code>UsingUVChannels.NonMesh</code>を使用してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;_MatCapTexture&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;_MatCapTexture&#34;</span>,
</span></span><span style=display:flex><span>    UsingUVChannels.NonMesh,  <span style=color:#75715e>// メッシュUVを使用しない</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span>  <span style=color:#75715e>// UV変換なし</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>UVチャンネルがマテリアルプロパティに依存する場合は、以下のようにします。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> uvChannel = matInfo.GetFloat(<span style=color:#e6db74>&#34;_UVChannel&#34;</span>) <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span> =&gt; UsingUVChannels.UV0,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> =&gt; UsingUVChannels.UV1,
</span></span><span style=display:flex><span>    _ =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1  <span style=color:#75715e>// 不明、どちらにもなる可能性あり</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>matInfo.RegisterTextureUVUsage(<span style=color:#e6db74>&#34;_DetailTex&#34;</span>, <span style=color:#e6db74>&#34;_DetailTex&#34;</span>, uvChannel, uvMatrix);
</span></span></code></pre></div><h4 id=uv-transform-matrices>UV変換行列
<a class=anchor href=#uv-transform-matrices>#</a></h4><p>UV変換行列では、UVがどのようにスケール調整およびオフセットされるかを記述します。(例: <code>_MainTex_ST</code>)<br>ほとんどのUnityシェーダーは<code>(scaleX, scaleY, offsetX, offsetY)</code>のVector4を使用しています。<br>スケール調整とオフセットは<code>Matrix2x3.NewScaleOffset</code>メソッドを使用して<code>Matrix2x3</code>に変換できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> texST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>Matrix2x3? uvMatrix = texST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>    ? Matrix2x3.NewScaleOffset(st)
</span></span><span style=display:flex><span>    : <span style=color:#66d9ef>null</span>;
</span></span></code></pre></div><p>必要に応じてこれを手動で構築することもできます。<br>UV変換がアニメーションで操作可能であるか、動的に計算されるような場合には、<code>null</code>を使用してください。</p><h3 id=register-vertex-index>頂点インデックス使用状況の登録
<a class=anchor href=#register-vertex-index>#</a></h3><p>シェーダーが頂点インデックス使用状況を登録すると、Avatar Optimizerは元のメッシュから頂点インデックスを保持しようとします。<br>これは現在、Trace and Optimizeの自動メッシュ統合を無効にしますが、将来的にはより多くの機能が影響を受ける可能性があります。</p><p>この方法は頂点インデックスを保持するためのものです。<br>シェーダーがランダムなシーケンスを生成する目的でのみ頂点インデックスを使用している場合は登録する必要がないため、<code>RegisterVertexIndexUsage</code>メソッドを呼び出すべきではありません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... テクスチャを登録 ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 頂点インデックスを使用する機能が有効かチェック</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (matInfo.GetFloat(<span style=color:#e6db74>&#34;_UseVertexIdEffect&#34;</span>) != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// このシェーダーがAvatar Optimizerに頂点インデックスを保持することを望んでいることを伝える</span>
</span></span><span style=display:flex><span>        matInfo.RegisterVertexIndexUsage();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=registration-methods>Shader Informationの登録
<a class=anchor href=#registration-methods>#</a></h2><p>シェーダーと情報を紐付けるには、<code>ShaderInformation</code>の実装を登録する必要があります。<br>Shader Informationを登録する方法には、以下の2つがあります。</p><h3 id=register-by-guid>GUIDで登録する (推奨)
<a class=anchor href=#register-by-guid>#</a></h3><p>シェーダーアセットの場合、シェーダーのGUIDを使用して登録できます。<br>GUIDは通常変更されず、重複もせず、AssetDatabaseへのアクセスを必要としないため、この方法の使用を推奨します。<br>(InitializeOnLoadなメソッドでのAssetDatabaseへのアクセスは無効であるため、シェーダーインスタンスによる登録は動作しない可能性があります)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;your-shader-asset-guid&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=register-by-instance>シェーダーインスタンスで登録する
<a class=anchor href=#register-by-instance>#</a></h3><p>ビルド時に動的に作成されるシェーダー、またはシェーダーインスタンスがある場合は、シェーダーインスタンスを登録することができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span>Shader shader = Shader.Find(<span style=color:#e6db74>&#34;Your/Shader/Name&#34;</span>);
</span></span><span style=display:flex><span>ShaderInformationRegistry.RegisterShaderInformation(
</span></span><span style=display:flex><span>    shader,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h2 id=best-practices>ベストプラクティス
<a class=anchor href=#best-practices>#</a></h2><h3 id=use-initializeonload>InitializeOnLoadを使用する
<a class=anchor href=#use-initializeonload>#</a></h3><p><code>[InitializeOnLoad]</code>を使用してstaticコンストラクタでShader Informationを登録し、&lsquo;Apply on Play&rsquo;用ビルド処理の前に登録してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>YourShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> YourShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Unityがロードされると自動的に登録されます</span>
</span></span><span style=display:flex><span>        Register();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Register()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;guid&#34;</span>, <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=handle-unknown-values>nullの取り扱い
<a class=anchor href=#handle-unknown-values>#</a></h3><p>マテリアルプロパティはアニメーションで操作されたり、不明であったりする可能性があります。<br><code>null</code>値を想定して処理してください。シェーダー自身はアニメーションでのプロパティ操作をサポートしていない場合でも、Avatar Optimizerが一度に複数のマテリアルを処理することにより<code>null</code>が渡される可能性があります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// パターンマッチングを使用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> st = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>Matrix2x3? uvMatrix = st <span style=color:#66d9ef>is</span> { } st2 ? Matrix2x3.NewScaleOffset(st2) : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// nullの場合も考慮してUVチャンネルを決定</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> uvChannel = matInfo.GetFloat(<span style=color:#e6db74>&#34;_UVChannel&#34;</span>) <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span> =&gt; UsingUVChannels.UV0,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> =&gt; UsingUVChannels.UV1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span> =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1,  <span style=color:#75715e>// 不明</span>
</span></span><span style=display:flex><span>    _ =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=check-keywords-properties>キーワードとプロパティを確認する
<a class=anchor href=#check-keywords-properties>#</a></h3><p>実際に使用されているテクスチャのみを登録してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>if</span> (matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;_NORMALMAP&#34;</span>) != <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// キーワードが有効な可能性、法線マップを登録</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (matInfo.GetFloat(<span style=color:#e6db74>&#34;_UseEmission&#34;</span>) != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// エミッションが有効、エミッションマップを登録</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote class="book-hint info"><p><code>!= false</code>は、値が<code>true</code>または<code>null</code>(不明)かどうかをチェックするのに用います。<br>この保守的なアプローチで、不明な場合に機能が有効であると仮定することができます。</p></blockquote><h3 id=provide-accurate-information>正確な情報を提供する
<a class=anchor href=#provide-accurate-information>#</a></h3><ul><li>頂点インデックスが本当に重要な場合にのみ<code>VertexIndexUsage</code>を設定する</li><li>正しいサンプラー状態を使用する (アトラス化のテクスチャフィルタリングに影響します)</li><li>UV行列が動的に変化するか、アニメーションで操作される場合は<code>null</code>に設定</li><li>スクリーンスペースのUVには<code>UsingUVChannels.NonMesh</code>を使用する</li></ul><h3 id=use-internal-class>Shader Informationクラスに<code>internal class</code>を使用する
<a class=anchor href=#use-internal-class>#</a></h3><p>Shader Informationクラスをアセンブリの公開APIとして晒してしまわないために、<code>internal class</code> として宣言することを推奨します。<br>これによりコードベースがクリーンになり、内部の実装詳細が誤って外部から使用されるのを防ぐことができます。</p><p>エディタ用スクリプト側に公開APIがない場合は、asmdefファイルのAuto Referenceをfalseに設定することで、クラスが<code>Assembly-CSharp</code>に対して使用可能になるのを防ぐことができます。</p><h2 id=examples>記述例
<a class=anchor href=#examples>#</a></h2><p>シンプルなシェーダーのためのShaderInformationの記述例です。</p><p>より複雑な例については、<a href=https://github.com/anatawa12/AvatarOptimizer/tree/master/Editor/APIInternal/>GitHub</a>にあるAvatar Optimizerの組み込みShaderInformation実装を参照してください。</p><h3 id=example-simple>メインテクスチャを持つシンプルなシェーダー
<a class=anchor href=#example-simple>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> SimpleShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;your-shader-guid&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> SimpleShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>        ShaderInformationKind.TextureAndUVUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>        Matrix2x3? uvMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>            ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>            : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>            UsingUVChannels.UV0,
</span></span><span style=display:flex><span>            uvMatrix
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=example-conditional>条件付きで機能が有効になるシェーダー
<a class=anchor href=#example-conditional>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FeatureShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> FeatureShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;your-shader-guid&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> FeatureShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>        ShaderInformationKind.TextureAndUVUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// メインテクスチャ (常に存在)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>        Matrix2x3? mainUVMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>            ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>            : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>, <span style=color:#e6db74>&#34;_MainTex&#34;</span>, UsingUVChannels.UV0, mainUVMatrix
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 法線マップ (キーワードに依存)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;_NORMALMAP&#34;</span>) != <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;_BumpMap&#34;</span>, <span style=color:#e6db74>&#34;_BumpMap&#34;</span>, UsingUVChannels.UV0, mainUVMatrix
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 詳細テクスチャ (プロパティに依存)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matInfo.GetFloat(<span style=color:#e6db74>&#34;_UseDetail&#34;</span>) != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> detailST = matInfo.GetVector(<span style=color:#e6db74>&#34;_DetailTex_ST&#34;</span>);
</span></span><span style=display:flex><span>            Matrix2x3? detailUVMatrix = detailST <span style=color:#66d9ef>is</span> { } st2 
</span></span><span style=display:flex><span>                ? Matrix2x3.NewScaleOffset(st2) 
</span></span><span style=display:flex><span>                : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> detailUV = matInfo.GetFloat(<span style=color:#e6db74>&#34;_DetailUV&#34;</span>) <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>0</span> =&gt; UsingUVChannels.UV0,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span> =&gt; UsingUVChannels.UV1,
</span></span><span style=display:flex><span>                _ =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;_DetailTex&#34;</span>, <span style=color:#e6db74>&#34;_DetailTex&#34;</span>, detailUV, detailUVMatrix
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// MatCap (スクリーンスペース、UV変換なし)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;_MATCAP&#34;</span>) != <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;_MatCap&#34;</span>,
</span></span><span style=display:flex><span>                SamplerStateInformation.LinearClampSampler,
</span></span><span style=display:flex><span>                UsingUVChannels.NonMesh,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=example-vertex-indices>頂点インデックスを使用するシェーダー
<a class=anchor href=#example-vertex-indices>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VertexShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> VertexShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;your-shader-guid&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> VertexShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>        ShaderInformationKind.TextureAndUVUsage | ShaderInformationKind.VertexIndexUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>        Matrix2x3? uvMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>            ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>            : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>, <span style=color:#e6db74>&#34;_MainTex&#34;</span>, UsingUVChannels.UV0, uvMatrix
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// シェーダーはエフェクトのためにSV_VertexIDを使用</span>
</span></span><span style=display:flex><span>        matInfo.RegisterVertexIndexUsage();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=support>サポート
<a class=anchor href=#support>#</a></h2><p>質問やサポートが必要な場合は、以下をご利用ください。</p><ul><li><strong>Discord</strong>: <a href=https://discord.gg/dV4cVpewmM>NDMF Discord</a> <code>@anatawa12</code>にメンション</li><li><strong>Fediverse</strong>: <a href=https://misskey.niri.la/@anatawa12>@anatawa12@misskey.niri.la</a></li><li><strong>GitHub Issues</strong>: <a href=https://github.com/anatawa12/AvatarOptimizer/issues>AvatarOptimizer Issues</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>例えば、現時点ではUVチャンネルの最適化は実装されていませんが、将来のバージョンで追加される可能性はあります。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Assembly-CSharp以外のアセンブリを定義するためのファイル。<a href=https://docs.unity3d.com/2022.3/Documentation/Manual/ScriptCompilationAssemblyDefinitionFiles.html>unity docs</a>を参照してください。&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/anatawa12/AvatarOptimizer/edit/master/.docs/content/docs/developers/shader-information/index.ja.md target=_blank rel=noopener><img src=/avatar-optimizer/beta/svg/edit.svg class=book-icon alt>
<span>このページを編集する</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-is-shader-information>Shader Informationとは？</a></li><li><a href=#core-concepts>コンセプト</a><ul><li><a href=#main-classes>主要なクラス</a></li><li><a href=#null-values>Null値</a></li></ul></li><li><a href=#getting-started>使い方</a><ul><li><a href=#create-asmdef>1. Assembly Definitionを作成する</a></li><li><a href=#add-reference>2. Assembly Referenceを追加する</a></li><li><a href=#create-class>3. Shader Informationクラスを作成</a></li></ul></li><li><a href=#information-kinds>ShaderInformationKindフラグ</a></li><li><a href=#registering-information>マテリアル情報の登録</a><ul><li><a href=#reading-properties>マテリアルプロパティの読み取り</a></li><li><a href=#registering-textures>テクスチャ使用状況の登録</a></li><li><a href=#register-vertex-index>頂点インデックス使用状況の登録</a></li></ul></li><li><a href=#registration-methods>Shader Informationの登録</a><ul><li><a href=#register-by-guid>GUIDで登録する (推奨)</a></li><li><a href=#register-by-instance>シェーダーインスタンスで登録する</a></li></ul></li><li><a href=#best-practices>ベストプラクティス</a><ul><li><a href=#use-initializeonload>InitializeOnLoadを使用する</a></li><li><a href=#handle-unknown-values>nullの取り扱い</a></li><li><a href=#check-keywords-properties>キーワードとプロパティを確認する</a></li><li><a href=#provide-accurate-information>正確な情報を提供する</a></li><li><a href=#use-internal-class>Shader Informationクラスに<code>internal class</code>を使用する</a></li></ul></li><li><a href=#examples>記述例</a><ul><li><a href=#example-simple>メインテクスチャを持つシンプルなシェーダー</a></li><li><a href=#example-conditional>条件付きで機能が有効になるシェーダー</a></li><li><a href=#example-vertex-indices>頂点インデックスを使用するシェーダー</a></li></ul></li><li><a href=#support>サポート</a></li></ul></nav></div></aside></main></body></html>