<!doctype html><html lang=ja dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="
  Shader Information API
  #

Avatar Optimizer v1.8.0以降は、カスタムシェーダーを使用するマテリアルの最適化を支援するShader Information APIを提供しています。シェーダー情報を登録することで、Avatar Optimizerがテクスチャのアトラス化やUVのパッキングなどの高度な最適化を実行できるようになります。

  Shader Informationとは？
  #

Shader Informationは、あなたのシェーダーがテクスチャ、UVチャンネル、その他のマテリアルプロパティをどのように使用しているかをAvatar Optimizerに伝える方法です。
現在のAvatar Optimizerはこの情報を用いて、以下の方法でアバターを最適化します。将来的にさらに多くの最適化が追加される可能性があります。1 ただし、すべての最適化が Trace and Optimize によって自動的に実行されるわけではありません。

複数のテクスチャをテクスチャアトラスにパッキング (AAO Merge Materialなどのコンポーネントを使用)
シェーダー機能で使用されているがマテリアル設定で無効化されているテクスチャを削除

Shader Informationがない場合、Avatar Optimizerはシェーダーを保守的に扱い、これらの最適化の一部を実行できません。

  コアコンセプト
  #


  主要なクラス
  #

Shader Information APIは3つの主要なクラスで構成されています:

ShaderInformation: シェーダーに関する情報を提供するために継承する基底クラス。GetMaterialInformationをオーバーライドして、シェーダーを使用するマテリアルのテクスチャとUV使用状況を登録します。
ShaderInformationRegistry: エディタ初期化中にShaderInformation実装をAvatar Optimizerに登録するために使用する静的クラス。
MaterialInformationCallback: GetMaterialInformationに渡され、マテリアルプロパティを読み取り、テクスチャ/UV使用情報を登録するメソッドを提供します。


  Null値
  #

Shader Information API全体を通して、null値には一貫した意味があります: 不明な値またはアニメーション化された(静的に決定不可能な)値を表します。マテリアルプロパティがアニメーション化されている可能性があるか、ビルド時にその値を決定できない場合、APIは不確実性を示すためにnullを返します。値を静的に決定できない場合は、パラメータにnullを渡す必要があります。

  はじめに
  #

シェーダーのShader Informationを提供するには、以下の手順に従ってください:

  1. Assembly Definitionを作成
  #

シェーダーパッケージにエディタ用のAssembly Definition（asmdef）がない場合は、作成してください。 Shader Informationはビルド時にのみ使用され、Shader Information APIはエディタでのみ利用可能なため、該当するアセンブリはエディタ専用にしてください。"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://vpm.anatawa12.com/avatar-optimizer/beta/ja/docs/developers/shader-information/"><meta property="og:site_name" content="Avatar Optimizer (1.9.0-rc.8)"><meta property="og:title" content="Shader Information API"><meta property="og:description" content="Shader Information API # Avatar Optimizer v1.8.0以降は、カスタムシェーダーを使用するマテリアルの最適化を支援するShader Information APIを提供しています。シェーダー情報を登録することで、Avatar Optimizerがテクスチャのアトラス化やUVのパッキングなどの高度な最適化を実行できるようになります。
Shader Informationとは？ # Shader Informationは、あなたのシェーダーがテクスチャ、UVチャンネル、その他のマテリアルプロパティをどのように使用しているかをAvatar Optimizerに伝える方法です。
現在のAvatar Optimizerはこの情報を用いて、以下の方法でアバターを最適化します。将来的にさらに多くの最適化が追加される可能性があります。1 ただし、すべての最適化が Trace and Optimize によって自動的に実行されるわけではありません。
複数のテクスチャをテクスチャアトラスにパッキング (AAO Merge Materialなどのコンポーネントを使用) シェーダー機能で使用されているがマテリアル設定で無効化されているテクスチャを削除 Shader Informationがない場合、Avatar Optimizerはシェーダーを保守的に扱い、これらの最適化の一部を実行できません。
コアコンセプト # 主要なクラス # Shader Information APIは3つの主要なクラスで構成されています:
ShaderInformation: シェーダーに関する情報を提供するために継承する基底クラス。GetMaterialInformationをオーバーライドして、シェーダーを使用するマテリアルのテクスチャとUV使用状況を登録します。 ShaderInformationRegistry: エディタ初期化中にShaderInformation実装をAvatar Optimizerに登録するために使用する静的クラス。 MaterialInformationCallback: GetMaterialInformationに渡され、マテリアルプロパティを読み取り、テクスチャ/UV使用情報を登録するメソッドを提供します。 Null値 # Shader Information API全体を通して、null値には一貫した意味があります: 不明な値またはアニメーション化された(静的に決定不可能な)値を表します。マテリアルプロパティがアニメーション化されている可能性があるか、ビルド時にその値を決定できない場合、APIは不確実性を示すためにnullを返します。値を静的に決定できない場合は、パラメータにnullを渡す必要があります。
はじめに # シェーダーのShader Informationを提供するには、以下の手順に従ってください:
1. Assembly Definitionを作成 # シェーダーパッケージにエディタ用のAssembly Definition（asmdef）がない場合は、作成してください。 Shader Informationはビルド時にのみ使用され、Shader Information APIはエディタでのみ利用可能なため、該当するアセンブリはエディタ専用にしてください。"><meta property="og:locale" content="ja"><meta property="og:type" content="article"><meta property="article:section" content="docs"><title>Shader Information API | Avatar Optimizer (1.9.0-rc.8)</title><link rel=icon href=/avatar-optimizer/beta/favicon.png><link rel=manifest href=/avatar-optimizer/beta/manifest.json><link rel=canonical href=https://vpm.anatawa12.com/avatar-optimizer/beta/ja/docs/developers/shader-information/><link rel=alternate hreflang=en href=https://vpm.anatawa12.com/avatar-optimizer/beta/en/docs/developers/shader-information/ title="Shader Information API"><link rel=stylesheet href=/avatar-optimizer/beta/book.min.60113a8b97a3ffc03c87f522a46a7f47cc2ab4570776eaf10e1f2527b80e37f4.css integrity="sha256-YBE6i5ej/8A8h/UipGp/R8wqtFcHdurxDh8lJ7gON/Q=" crossorigin=anonymous><script defer src=/avatar-optimizer/beta/fuse.min.js></script><script defer src=/avatar-optimizer/beta/ja.search.min.f0d887fa8f5f487609bec4db417b4c8cf30bfd682e119f49b39fea2e50572d78.js integrity="sha256-8NiH+o9fSHYJvsTbQXtMjPML/WguEZ9Js5/qLlBXLXg=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/avatar-optimizer/beta/ja/><span>Avatar Optimizer (1.9.0-rc.8)</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=検索 aria-label=検索 maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul class=book-languages><li><input type=checkbox id=languages class=toggle>
<label for=languages class="flex justify-between"><a role=button class="flex align-center"><img src=/avatar-optimizer/beta/svg/translate.svg class=book-icon alt=Languages>
日本語</a></label><ul><li><a href=/avatar-optimizer/beta/en/docs/developers/shader-information/>English</a></li></ul></li></ul><ul><li><a class=ao-stable-beta href=https://vpm.anatawa12.com/avatar-optimizer/ja/docs/developers/shader-information/>Goto Stable Docs</a></li><li><a class=ao-stable-beta href=https://vpm.anatawa12.com/avatar-optimizer/beta/ja/#installation>インストール方法</a></li></ul><ul><li class=book-section-flat><span>チュートリアル</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/tutorial/basic-usage/>基本的な使い方</a></li></ul></li><li><a href=/avatar-optimizer/beta/ja/docs/basic-concept/>基本コンセプト</a></li><li><a href=/avatar-optimizer/beta/ja/docs/faq/>よくある質問</a></li><li><a href=/avatar-optimizer/beta/ja/docs/changelog/>Changelog</a></li><li class=book-section-flat><span>コンポーネントの種類</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/component-kind/avatar-global-components/>Avatar Global Components</a></li><li><a href=/avatar-optimizer/beta/ja/docs/component-kind/edit-skinned-mesh-components/>Edit Skinned Mesh Components</a></li></ul></li><li class=book-section-flat><span>コンポーネントの詳細説明</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/reference/trace-and-optimize/>Trace And Optimize</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-skinned-mesh/>Merge Skinned Mesh</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/freeze-blendshape/>Freeze BlendShape</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/max-texture-size/>Max Texture Size</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-material/>Merge Material</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-blendshape/>Remove Mesh By BlendShape</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-box/>Remove Mesh By Box</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-mask/>Remove Mesh By Mask</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-mesh-by-uv-tile/>Remove Mesh By UV Tile</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/rename-blendshape/>Rename BlendShape</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/clear-endpoint-position/>Clear Endpoint Position</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-bone/>Merge Bone</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-physbone/>Merge PhysBone</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/remove-zero-sized-polygon/>Remove Zero Sized Polygon</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/replace-end-bone-with-endpoint-position/>Replace End Bone With Endpoint Position</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/make-children/>Make Children</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/merge-toonlit-material/>Merge ToonLit Material</a></li><li><a href=/avatar-optimizer/beta/ja/docs/reference/unused-bones-by-references-tool/>UnusedBonesByReferencesTool</a></li></ul></li><li class=book-section-flat><span>開発者向け</span><ul><li><a href=/avatar-optimizer/beta/ja/docs/developers/system-assumptions/>システムの前提条件</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/asset-description/>Asset Description</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/component-api/>Component Scripting API</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/shader-information/ class=active>Shader Information API</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/distributing-prefabs/>アセットの配布について</a></li><li><a href=/avatar-optimizer/beta/ja/docs/developers/make-your-components-compatible-with-aao/>コンポーネントにAvatar Optimizerとの互換性をもたせる</a></li></ul></li></ul><ul><li class=book-section-flat><span>Blog Posts</span><ul><li><a href=/avatar-optimizer/beta/ja/posts/2024-06-27-one-year-since-stable-release/>v1.0.0一周年を記念してちょっと歴史を振り返る</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/avatar-optimizer/beta/svg/menu.svg class=book-icon alt=Menu></label><h3>Shader Information API</h3><label for=toc-control><img src=/avatar-optimizer/beta/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#what-is-shader-information>Shader Informationとは？</a></li><li><a href=#core-concepts>コアコンセプト</a><ul><li><a href=#main-classes>主要なクラス</a></li><li><a href=#null-values>Null値</a></li></ul></li><li><a href=#getting-started>はじめに</a><ul><li><a href=#create-asmdef>1. Assembly Definitionを作成</a></li><li><a href=#add-reference>2. Assembly Referenceを追加</a></li><li><a href=#create-class>3. Shader Informationクラスを作成</a></li></ul></li><li><a href=#information-kinds>ShaderInformationKindフラグ</a></li><li><a href=#registering-information>マテリアル情報の登録</a><ul><li><a href=#reading-properties>マテリアルプロパティの読み取り</a></li><li><a href=#registering-textures>テクスチャ使用状況の登録</a></li><li><a href=#register-vertex-index>頂点インデックス使用状況の登録</a></li></ul></li><li><a href=#registration-methods>Shader Informationの登録</a><ul><li><a href=#register-by-guid>GUIDで登録 (推奨)</a></li><li><a href=#register-by-instance>シェーダーインスタンスで登録</a></li></ul></li><li><a href=#best-practices>ベストプラクティス</a><ul><li><a href=#use-initializeonload>InitializeOnLoadを使用</a></li><li><a href=#handle-unknown-values>不明な値を処理</a></li><li><a href=#check-keywords-properties>キーワードとプロパティをチェック</a></li><li><a href=#provide-accurate-information>正確な情報を提供</a></li><li><a href=#use-internal-class>Shader Informationクラスに<code>internal class</code>を使用する</a></li></ul></li><li><a href=#examples>完全な例</a><ul><li><a href=#example-simple>メインテクスチャを持つシンプルなシェーダー</a></li><li><a href=#example-conditional>条件付き機能を持つシェーダー</a></li><li><a href=#example-vertex-indices>頂点インデックスを使用するシェーダー</a></li></ul></li><li><a href=#support>サポート</a></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=shader-information-api>Shader Information API
<a class=anchor href=#shader-information-api>#</a></h1><p>Avatar Optimizer v1.8.0以降は、カスタムシェーダーを使用するマテリアルの最適化を支援するShader Information APIを提供しています。シェーダー情報を登録することで、Avatar Optimizerがテクスチャのアトラス化やUVのパッキングなどの高度な最適化を実行できるようになります。</p><h2 id=what-is-shader-information>Shader Informationとは？
<a class=anchor href=#what-is-shader-information>#</a></h2><p>Shader Informationは、あなたのシェーダーがテクスチャ、UVチャンネル、その他のマテリアルプロパティをどのように使用しているかをAvatar Optimizerに伝える方法です。</p><p>現在のAvatar Optimizerはこの情報を用いて、以下の方法でアバターを最適化します。将来的にさらに多くの最適化が追加される可能性があります。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> ただし、すべての最適化が Trace and Optimize によって自動的に実行されるわけではありません。</p><ul><li>複数のテクスチャをテクスチャアトラスにパッキング (<code>AAO Merge Material</code>などのコンポーネントを使用)</li><li>シェーダー機能で使用されているがマテリアル設定で無効化されているテクスチャを削除</li></ul><p>Shader Informationがない場合、Avatar Optimizerはシェーダーを保守的に扱い、これらの最適化の一部を実行できません。</p><h2 id=core-concepts>コアコンセプト
<a class=anchor href=#core-concepts>#</a></h2><h3 id=main-classes>主要なクラス
<a class=anchor href=#main-classes>#</a></h3><p>Shader Information APIは3つの主要なクラスで構成されています:</p><ul><li><code>ShaderInformation</code>: シェーダーに関する情報を提供するために継承する基底クラス。<code>GetMaterialInformation</code>をオーバーライドして、シェーダーを使用するマテリアルのテクスチャとUV使用状況を登録します。</li><li><code>ShaderInformationRegistry</code>: エディタ初期化中に<code>ShaderInformation</code>実装をAvatar Optimizerに<a href=#registration-methods>登録</a>するために使用する静的クラス。</li><li><code>MaterialInformationCallback</code>: <code>GetMaterialInformation</code>に渡され、マテリアルプロパティを読み取り、テクスチャ/UV使用情報を登録するメソッドを提供します。</li></ul><h3 id=null-values>Null値
<a class=anchor href=#null-values>#</a></h3><p>Shader Information API全体を通して、<code>null</code>値には一貫した意味があります: <strong>不明な値</strong>または<strong>アニメーション化された(静的に決定不可能な)値</strong>を表します。マテリアルプロパティがアニメーション化されている可能性があるか、ビルド時にその値を決定できない場合、APIは不確実性を示すために<code>null</code>を返します。値を静的に決定できない場合は、パラメータに<code>null</code>を渡す必要があります。</p><h2 id=getting-started>はじめに
<a class=anchor href=#getting-started>#</a></h2><p>シェーダーのShader Informationを提供するには、以下の手順に従ってください:</p><h3 id=create-asmdef>1. Assembly Definitionを作成
<a class=anchor href=#create-asmdef>#</a></h3><p>シェーダーパッケージにエディタ用のAssembly Definition（asmdef）がない場合は、作成してください。 Shader Informationはビルド時にのみ使用され、Shader Information APIはエディタでのみ利用可能なため、該当するアセンブリはエディタ専用にしてください。</p><h3 id=add-reference>2. Assembly Referenceを追加
<a class=anchor href=#add-reference>#</a></h3><p>assembly definitionの参照に<code>com.anatawa12.avatar-optimizer.api.editor</code>を追加してください。</p><p>Avatar Optimizerを必須の依存関係にしたくない場合は、<code>AVATAR_OPTIMIZER</code>のようなシンボルで<a href=https://docs.unity3d.com/2019.4/Documentation/Manual/ScriptCompilationAssemblyDefinitionFiles.html#define-symbols>Version Defines</a>を使用して、Avatar Optimizerがインストールされているか、AAOバージョンが指定されたバージョンより新しいかを検出してください。</p><p><img src=../version-defines.png alt=version-defines.png></p><p><code>[1.8,2.0)</code>のようなバージョン範囲を推奨します (v1.8.0以降をサポートしますが、v2.0.0では更新が必要になります)。一部のAPIは後のバージョンで追加された可能性があるため、使用するAPIに基づいてバージョン範囲を調整する必要がある場合があることに注意してください。</p><h3 id=create-class>3. Shader Informationクラスを作成
<a class=anchor href=#create-class>#</a></h3><p><code>ShaderInformation</code>を継承するクラスを作成し、<code>ShaderInformationRegistry</code>に登録してください。
Avatar Optimizerがマテリアルを処理する前に登録されることを保証するため、登録は<code>[InitializeOnLoad]</code>属性とstaticコンストラクタを使って行ってください:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>#if</span> AVATAR_OPTIMIZER &amp;&amp; UNITY_EDITOR
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Anatawa12.AvatarOptimizer.API;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEditor;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>namespace</span> YourNamespace
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [InitializeOnLoad]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>YourShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> YourShaderInformation()
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// シェーダーGUIDで登録 (シェーダーアセットに推奨)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>string</span> shaderGuid = <span style=color:#e6db74>&#34;your-shader-guid-here&#34;</span>;
</span></span><span style=display:flex><span>            ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>                shaderGuid, 
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>            ShaderInformationKind.TextureAndUVUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// ここでテクスチャとUV使用状況を登録 (以下の例を参照)</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><h2 id=information-kinds>ShaderInformationKindフラグ
<a class=anchor href=#information-kinds>#</a></h2><p><code>SupportedInformationKind</code>プロパティは、提供している情報をAvatar Optimizerに伝えます。</p><p>現在、2つの情報種類があります:</p><ul><li><code>TextureAndUVUsage</code>: シェーダーが使用するテクスチャ、各テクスチャがサンプリングするUVチャンネル、UV変換マトリックス、サンプラーステートに関する情報を提供していることを示します。<a href=#registering-textures>テクスチャ使用状況の登録</a>を参照してください。</li><li><code>VertexIndexUsage</code>: シェーダーが頂点インデックス (例: <code>SV_VertexID</code>) を使用していることを示します。このフラグを提供しない場合、Avatar Optimizerは頂点インデックスが使用されていないと仮定し、最適化中に頂点をシャッフルする可能性があります。<a href=#register-vertex-index>頂点インデックス使用状況の登録</a>を参照してください。</li></ul><p>これはフラグ列挙型なので、<code>|</code>演算子で複数の値を組み合わせることができます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>    ShaderInformationKind.TextureAndUVUsage | ShaderInformationKind.VertexIndexUsage;
</span></span></code></pre></div><h2 id=registering-information>マテリアル情報の登録
<a class=anchor href=#registering-information>#</a></h2><p><code>GetMaterialInformation</code>メソッドは、シェーダーを使用する各マテリアルに対して呼び出されます。
<code>MaterialInformationCallback</code>を使用してテクスチャとUV使用状況を登録してください。</p><p>各メソッドの詳細については、APIドキュメントコメントを参照してください。</p><h3 id=reading-properties>マテリアルプロパティの読み取り
<a class=anchor href=#reading-properties>#</a></h3><p>コールバックは、シェーダー上のマテリアルプロパティを読み取るメソッドを提供します:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// floatプロパティを読み取り</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>float?</span> <span style=color:#66d9ef>value</span> = matInfo.GetFloat(<span style=color:#e6db74>&#34;_PropertyName&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// intプロパティを読み取り</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int?</span> <span style=color:#66d9ef>value</span> = matInfo.GetInt(<span style=color:#e6db74>&#34;_PropertyName&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Vector4プロパティを読み取り (_MainTex_STなど)</span>
</span></span><span style=display:flex><span>Vector4? <span style=color:#66d9ef>value</span> = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// シェーダーキーワードが有効かどうかをチェック</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>bool?</span> enabled = matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;KEYWORD_NAME&#34;</span>);
</span></span></code></pre></div><p>これらのメソッドは、プロパティが存在しないか値が不明な場合に<code>null</code>を返します。</p><h3 id=registering-textures>テクスチャ使用状況の登録
<a class=anchor href=#registering-textures>#</a></h3><p><code>RegisterTextureUVUsage</code>を使用して、各2Dテクスチャについて Avatar Optimizerに伝えます。パラメータの詳細については、APIドキュメントコメントを参照してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// UV変換 (スケール/オフセット) を取得</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>    Matrix2x3? uvMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>        ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>        : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// テクスチャを登録</span>
</span></span><span style=display:flex><span>    matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>        textureMaterialPropertyName: <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>        samplerState: <span style=color:#e6db74>&#34;_MainTex&#34;</span>,  <span style=color:#75715e>// _MainTexプロパティのサンプラーを使用</span>
</span></span><span style=display:flex><span>        uvChannels: UsingUVChannels.UV0,
</span></span><span style=display:flex><span>        uvMatrix: uvMatrix
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=sampler-states>サンプラーステート
<a class=anchor href=#sampler-states>#</a></h4><p>サンプラーステートはテクスチャのラッピングとフィルタリングを定義します。ほとんどのシェーダーはマテリアルプロパティのサンプラーを使用します - プロパティ名を使用してください (文字列は暗黙的に<code>SamplerStateInformation</code>に変換されます):</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>    samplerState: <span style=color:#e6db74>&#34;_MainTex&#34;</span>,  <span style=color:#75715e>// 文字列は暗黙的に変換されます</span>
</span></span><span style=display:flex><span>    UsingUVChannels.UV0,
</span></span><span style=display:flex><span>    uvMatrix
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>シェーダーがインラインサンプラーを使用している場合 (例: <code>SamplerState linearClampSampler</code>)、<code>SamplerStateInformation.LinearRepeatSampler</code>のような定義済みの定数を使用してください。</p><p>サンプラーを判定できない場合は、<code>SamplerStateInformation.Unknown</code>を使用してください。</p><h4 id=uv-channels>UVチャンネル
<a class=anchor href=#uv-channels>#</a></h4><p><code>UsingUVChannels</code>を使用して、テクスチャがサンプリングするUVチャンネルを指定します。メッシュUVを使用しないテクスチャ (スクリーンスペース、MatCap、ビュー方向ベースなど) の場合は、<code>UsingUVChannels.NonMesh</code>を使用してください:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;_MatCapTexture&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;_MatCapTexture&#34;</span>, 
</span></span><span style=display:flex><span>    UsingUVChannels.NonMesh,  <span style=color:#75715e>// メッシュUVからではない</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span>  <span style=color:#75715e>// UV変換なし</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>UVチャンネルがマテリアルプロパティに依存する場合:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> uvChannel = matInfo.GetFloat(<span style=color:#e6db74>&#34;_UVChannel&#34;</span>) <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span> =&gt; UsingUVChannels.UV0,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> =&gt; UsingUVChannels.UV1,
</span></span><span style=display:flex><span>    _ =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1  <span style=color:#75715e>// 不明、どちらかの可能性</span>
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>matInfo.RegisterTextureUVUsage(<span style=color:#e6db74>&#34;_DetailTex&#34;</span>, <span style=color:#e6db74>&#34;_DetailTex&#34;</span>, uvChannel, uvMatrix);
</span></span></code></pre></div><h4 id=uv-transform-matrices>UV変換マトリックス
<a class=anchor href=#uv-transform-matrices>#</a></h4><p>UV変換マトリックスは、UVがどのようにスケールおよびオフセットされるかを記述します (<code>_MainTex_ST</code>のように)。ほとんどのUnityシェーダーは<code>(scaleX, scaleY, offsetX, offsetY)</code>のVector4を使用します:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>var</span> texST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>Matrix2x3? uvMatrix = texST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>    ? Matrix2x3.NewScaleOffset(st)
</span></span><span style=display:flex><span>    : <span style=color:#66d9ef>null</span>;
</span></span></code></pre></div><p>必要に応じてマトリックスを手動で構築することもできます。UV変換がアニメーション化されているか動的に計算される場合は、<code>null</code>を使用してください。</p><h3 id=register-vertex-index>頂点インデックス使用状況の登録
<a class=anchor href=#register-vertex-index>#</a></h3><p>シェーダーが頂点インデックス使用状況を登録すると、Avatar Optimizerは元のメッシュから頂点インデックスを保持しようとします。
これは現在、Trace and Optimizeの自動Merge Skinned Mesh機能を無効にしますが、将来的にはより多くの機能が影響を受ける可能性があります。</p><p>このメソッドは頂点インデックスを保持するためのものです。シェーダーがランダムなシーケンスを生成する目的でのみ頂点インデックスを使用している場合は、RegisterVertexIndexUsage を呼び出すべきではありません。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... テクスチャを登録 ...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// 頂点インデックスを使用する機能が有効かチェック</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (matInfo.GetFloat(<span style=color:#e6db74>&#34;_UseVertexIdEffect&#34;</span>) != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// このシェーダーがAvatar Optimizerに頂点インデックスを保持することを望んでいることを伝える</span>
</span></span><span style=display:flex><span>        matInfo.RegisterVertexIndexUsage();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=registration-methods>Shader Informationの登録
<a class=anchor href=#registration-methods>#</a></h2><p>シェーダーに情報をリンクするには、ShaderInformation実装を登録する必要があります。
Shader Informationを登録する方法は2つあります:</p><h3 id=register-by-guid>GUIDで登録 (推奨)
<a class=anchor href=#register-by-guid>#</a></h3><p>シェーダーアセットの場合、シェーダーのGUIDを使用します。このメソッドは、GUIDが変更されず、重複せず、AssetDatabaseへのアクセスを必要としないため推奨されます (InitializeOnLoadメソッドでAssetDatabaseにアクセスすることは無効であるため、シェーダーインスタンスによる登録は無効になる可能性があります)。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>&#34;your-shader-asset-guid&#34;</span>,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h3 id=register-by-instance>シェーダーインスタンスで登録
<a class=anchor href=#register-by-instance>#</a></h3><p>ビルド時に動的に作成されるシェーダー、またはシェーダーインスタンスがある場合、シェーダーインスタンスで登録できます。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span>Shader shader = Shader.Find(<span style=color:#e6db74>&#34;Your/Shader/Name&#34;</span>);
</span></span><span style=display:flex><span>ShaderInformationRegistry.RegisterShaderInformation(
</span></span><span style=display:flex><span>    shader,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h2 id=best-practices>ベストプラクティス
<a class=anchor href=#best-practices>#</a></h2><h3 id=use-initializeonload>InitializeOnLoadを使用
<a class=anchor href=#use-initializeonload>#</a></h3><p><code>[InitializeOnLoad]</code>を使用してstatic constructorでShader Informationを登録し、&lsquo;apply on play&rsquo;ビルドの前に登録してください。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>YourShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> YourShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Unityがロードされると自動的に登録されます</span>
</span></span><span style=display:flex><span>        Register();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> Register()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;guid&#34;</span>, <span style=color:#66d9ef>new</span> YourShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=handle-unknown-values>不明な値を処理
<a class=anchor href=#handle-unknown-values>#</a></h3><p>マテリアルプロパティはアニメーション化されている可能性があります。<code>null</code>値を想定して処理してください。シェーダーがプロパティのアニメーション化をサポートしていない場合でも、Avatar Optimizerが一度に複数のマテリアルを処理することにより<code>null</code>が渡されることがあります。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#75715e>// パターンマッチングを使用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> st = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>Matrix2x3? uvMatrix = st <span style=color:#66d9ef>is</span> { } st2 ? Matrix2x3.NewScaleOffset(st2) : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// nullの場合も考慮してUVチャンネルを決定</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> uvChannel = matInfo.GetFloat(<span style=color:#e6db74>&#34;_UVChannel&#34;</span>) <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>0</span> =&gt; UsingUVChannels.UV0,
</span></span><span style=display:flex><span>    <span style=color:#ae81ff>1</span> =&gt; UsingUVChannels.UV1,
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>null</span> =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1,  <span style=color:#75715e>// 不明</span>
</span></span><span style=display:flex><span>    _ =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><h3 id=check-keywords-properties>キーワードとプロパティをチェック
<a class=anchor href=#check-keywords-properties>#</a></h3><p>実際に使用されているテクスチャのみを登録してください:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>if</span> (matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;_NORMALMAP&#34;</span>) != <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// キーワードが有効な可能性、法線マップを登録</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> (matInfo.GetFloat(<span style=color:#e6db74>&#34;_UseEmission&#34;</span>) != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>// エミッションが有効、エミッションマップを登録</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p><strong>注意:</strong> <code>!= false</code>は、値が<code>true</code>または<code>null</code> (不明) かどうかをチェックします。
この保守的なアプローチは、不明な場合に機能が有効であると仮定します。</p><h3 id=provide-accurate-information>正確な情報を提供
<a class=anchor href=#provide-accurate-information>#</a></h3><ul><li>頂点インデックスが本当に重要な場合にのみ<code>VertexIndexUsage</code>を設定</li><li>正しいサンプラーステートを使用 (アトラス化中のテクスチャフィルタリングに影響)</li><li>UV行列が動的またはアニメーション化されている場合は<code>null</code>に設定</li><li>スクリーンスペースUVには<code>UsingUVChannels.NonMesh</code>を使用</li></ul><h3 id=use-internal-class>Shader Informationクラスに<code>internal class</code>を使用する
<a class=anchor href=#use-internal-class>#</a></h3><p>Shader Informationクラスをアセンブリの公開APIにさらさないために、<code>internal class</code> として宣言することを推奨します。これによりコードベースがクリーンになり、内部の実装詳細が誤って外部から使用されるのを防げます。</p><p>エディタ側に公開APIがない場合、アセンブリ定義の Auto Reference を false に設定して、クラスが <code>Assembly-CSharp</code> に露出するのを防ぐことができます。</p><h2 id=examples>完全な例
<a class=anchor href=#examples>#</a></h2><p>シンプルなシェーダーのためのシンプルなShaderInformation例です。</p><p>より複雑な例については、<a href=https://github.com/anatawa12/AvatarOptimizer/tree/master/Editor/APIInternal/>GitHub</a>にあるAvatar Optimizerの組み込みシェーダー情報実装を参照してください。</p><h3 id=example-simple>メインテクスチャを持つシンプルなシェーダー
<a class=anchor href=#example-simple>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SimpleShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> SimpleShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;your-shader-guid&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> SimpleShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>        ShaderInformationKind.TextureAndUVUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>        Matrix2x3? uvMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>            ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>            : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>,
</span></span><span style=display:flex><span>            UsingUVChannels.UV0,
</span></span><span style=display:flex><span>            uvMatrix
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=example-conditional>条件付き機能を持つシェーダー
<a class=anchor href=#example-conditional>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>FeatureShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> FeatureShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;your-shader-guid&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> FeatureShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>        ShaderInformationKind.TextureAndUVUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// メインテクスチャ (常に存在)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>        Matrix2x3? mainUVMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>            ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>            : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>, <span style=color:#e6db74>&#34;_MainTex&#34;</span>, UsingUVChannels.UV0, mainUVMatrix
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 法線マップ (キーワードに依存)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;_NORMALMAP&#34;</span>) != <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;_BumpMap&#34;</span>, <span style=color:#e6db74>&#34;_BumpMap&#34;</span>, UsingUVChannels.UV0, mainUVMatrix
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 詳細テクスチャ (プロパティに依存)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matInfo.GetFloat(<span style=color:#e6db74>&#34;_UseDetail&#34;</span>) != <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> detailST = matInfo.GetVector(<span style=color:#e6db74>&#34;_DetailTex_ST&#34;</span>);
</span></span><span style=display:flex><span>            Matrix2x3? detailUVMatrix = detailST <span style=color:#66d9ef>is</span> { } st2 
</span></span><span style=display:flex><span>                ? Matrix2x3.NewScaleOffset(st2) 
</span></span><span style=display:flex><span>                : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>var</span> detailUV = matInfo.GetFloat(<span style=color:#e6db74>&#34;_DetailUV&#34;</span>) <span style=color:#66d9ef>switch</span>
</span></span><span style=display:flex><span>            {
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>0</span> =&gt; UsingUVChannels.UV0,
</span></span><span style=display:flex><span>                <span style=color:#ae81ff>1</span> =&gt; UsingUVChannels.UV1,
</span></span><span style=display:flex><span>                _ =&gt; UsingUVChannels.UV0 | UsingUVChannels.UV1
</span></span><span style=display:flex><span>            };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;_DetailTex&#34;</span>, <span style=color:#e6db74>&#34;_DetailTex&#34;</span>, detailUV, detailUVMatrix
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// MatCap (スクリーンスペース、UV変換なし)</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (matInfo.IsShaderKeywordEnabled(<span style=color:#e6db74>&#34;_MATCAP&#34;</span>) != <span style=color:#66d9ef>false</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>                <span style=color:#e6db74>&#34;_MatCap&#34;</span>,
</span></span><span style=display:flex><span>                SamplerStateInformation.LinearClampSampler,
</span></span><span style=display:flex><span>                UsingUVChannels.NonMesh,
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>null</span>
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=example-vertex-indices>頂点インデックスを使用するシェーダー
<a class=anchor href=#example-vertex-indices>#</a></h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#a6e22e>[InitializeOnLoad]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>VertexShaderInformation</span> : ShaderInformation
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>static</span> VertexShaderInformation()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        ShaderInformationRegistry.RegisterShaderInformationWithGUID(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;your-shader-guid&#34;</span>,
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>new</span> VertexShaderInformation()
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> ShaderInformationKind SupportedInformationKind =&gt;
</span></span><span style=display:flex><span>        ShaderInformationKind.TextureAndUVUsage | ShaderInformationKind.VertexIndexUsage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>void</span> GetMaterialInformation(MaterialInformationCallback matInfo)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> mainTexST = matInfo.GetVector(<span style=color:#e6db74>&#34;_MainTex_ST&#34;</span>);
</span></span><span style=display:flex><span>        Matrix2x3? uvMatrix = mainTexST <span style=color:#66d9ef>is</span> { } st 
</span></span><span style=display:flex><span>            ? Matrix2x3.NewScaleOffset(st) 
</span></span><span style=display:flex><span>            : <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        matInfo.RegisterTextureUVUsage(
</span></span><span style=display:flex><span>            <span style=color:#e6db74>&#34;_MainTex&#34;</span>, <span style=color:#e6db74>&#34;_MainTex&#34;</span>, UsingUVChannels.UV0, uvMatrix
</span></span><span style=display:flex><span>        );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// シェーダーは効果のためにSV_VertexIDを使用</span>
</span></span><span style=display:flex><span>        matInfo.RegisterVertexIndexUsage();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=support>サポート
<a class=anchor href=#support>#</a></h2><p>質問やサポートが必要な場合は、以下をご利用ください。</p><ul><li><strong>Discord</strong>: <a href=https://discord.gg/dV4cVpewmM>NDMF Discord</a> <code>@anatawa12</code>にメンション</li><li><strong>Fediverse</strong>: <a href=https://misskey.niri.la/@anatawa12>@anatawa12@misskey.niri.la</a></li><li><strong>GitHub Issues</strong>: <a href=https://github.com/anatawa12/AvatarOptimizer/issues>AvatarOptimizer Issues</a></li></ul><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>例えば、UVチャンネル最適化は現在実装されていませんが、将来のバージョンで追加される可能性があります。&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/anatawa12/AvatarOptimizer/edit/master/.docs/content/docs/developers/shader-information/index.ja.md target=_blank rel=noopener><img src=/avatar-optimizer/beta/svg/edit.svg class=book-icon alt>
<span>このページを編集する</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#what-is-shader-information>Shader Informationとは？</a></li><li><a href=#core-concepts>コアコンセプト</a><ul><li><a href=#main-classes>主要なクラス</a></li><li><a href=#null-values>Null値</a></li></ul></li><li><a href=#getting-started>はじめに</a><ul><li><a href=#create-asmdef>1. Assembly Definitionを作成</a></li><li><a href=#add-reference>2. Assembly Referenceを追加</a></li><li><a href=#create-class>3. Shader Informationクラスを作成</a></li></ul></li><li><a href=#information-kinds>ShaderInformationKindフラグ</a></li><li><a href=#registering-information>マテリアル情報の登録</a><ul><li><a href=#reading-properties>マテリアルプロパティの読み取り</a></li><li><a href=#registering-textures>テクスチャ使用状況の登録</a></li><li><a href=#register-vertex-index>頂点インデックス使用状況の登録</a></li></ul></li><li><a href=#registration-methods>Shader Informationの登録</a><ul><li><a href=#register-by-guid>GUIDで登録 (推奨)</a></li><li><a href=#register-by-instance>シェーダーインスタンスで登録</a></li></ul></li><li><a href=#best-practices>ベストプラクティス</a><ul><li><a href=#use-initializeonload>InitializeOnLoadを使用</a></li><li><a href=#handle-unknown-values>不明な値を処理</a></li><li><a href=#check-keywords-properties>キーワードとプロパティをチェック</a></li><li><a href=#provide-accurate-information>正確な情報を提供</a></li><li><a href=#use-internal-class>Shader Informationクラスに<code>internal class</code>を使用する</a></li></ul></li><li><a href=#examples>完全な例</a><ul><li><a href=#example-simple>メインテクスチャを持つシンプルなシェーダー</a></li><li><a href=#example-conditional>条件付き機能を持つシェーダー</a></li><li><a href=#example-vertex-indices>頂点インデックスを使用するシェーダー</a></li></ul></li><li><a href=#support>サポート</a></li></ul></nav></div></aside></main></body></html>